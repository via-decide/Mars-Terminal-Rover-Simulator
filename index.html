<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>HEX-01 · Mars Geological Survey</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>

/* ============================================================
   DESIGN TOKENS
   ============================================================ */
:root {
  --bg:        #03050a;
  --surface:   #070d14;
  --panel:     #080e17;
  --border:    #12202e;
  --border-hi: #1e3348;
  --text:      #9ab4cc;
  --text-dim:  #334d63;
  --text-hi:   #c8dcea;
  --accent:    #00c8ff;
  --accent-dk: #004e66;
  --amber:     #ffaa00;
  --amber-dk:  #5a3a00;
  --red:       #ff3a3a;
  --red-dk:    #5a0a0a;
  --green:     #00e87a;
  --mono:      'Share Tech Mono', monospace;
  --display:   'Orbitron', sans-serif;
  --r:         2px;
}

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0; padding: 0;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  color: var(--text);
  font-family: var(--mono);
  font-size: 11px;
}

/* ============================================================
   FULL-SCREEN SCANLINE + NOISE OVERLAYS
   ============================================================ */
#overlay-scanlines {
  position: fixed; inset: 0; z-index: 999; pointer-events: none;
  background: repeating-linear-gradient(
    0deg,
    rgba(0,0,0,0.13) 0px,
    rgba(0,0,0,0.13) 1px,
    transparent 1px,
    transparent 3px
  );
}
#overlay-vignette {
  position: fixed; inset: 0; z-index: 998; pointer-events: none;
  background: radial-gradient(ellipse at 50% 50%, transparent 40%, rgba(0,0,0,0.72) 100%);
}
#overlay-grain {
  position: fixed; inset: 0; z-index: 997; pointer-events: none;
  opacity: 0.035;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  background-size: 120px 120px;
}

/* ============================================================
   SCREENS
   ============================================================ */
.screen {
  position: fixed; inset: 0;
  display: flex; flex-direction: column;
  opacity: 0; pointer-events: none;
  transition: opacity 0.5s ease;
}
.screen.active {
  opacity: 1; pointer-events: all;
}

/* ============================================================
   BOOT SCREEN
   ============================================================ */
#boot-screen {
  justify-content: center;
  align-items: flex-start;
  padding: 0 8% 0 10%;
  background: var(--bg);
}

.boot-header {
  font-family: var(--display);
  font-size: 10px;
  letter-spacing: 6px;
  color: var(--text-dim);
  margin-bottom: 44px;
  text-transform: uppercase;
}

.boot-log {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 40px;
  min-height: 180px;
}

.boot-line {
  font-size: 12px;
  line-height: 2.4;
  color: var(--text-dim);
  opacity: 0;
  animation: lineFadeIn 0.08s forwards;
  display: flex;
  gap: 12px;
  align-items: baseline;
}
.boot-line .bl-key   { color: var(--text); }
.boot-line .bl-val   { color: var(--accent); }
.boot-line .bl-ok    { color: var(--green); font-size: 9px; }
.boot-line .bl-warn  { color: var(--amber); }

@keyframes lineFadeIn { to { opacity: 1; } }

.boot-progress {
  width: 220px;
  height: 2px;
  background: var(--border);
  margin-bottom: 36px;
  overflow: hidden;
}
.boot-progress-fill {
  height: 100%;
  background: var(--accent);
  width: 0%;
  transition: width 0.3s ease;
}

.boot-cta {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  background: none;
  border: 1px solid var(--accent);
  color: var(--accent);
  font-family: var(--mono);
  font-size: 12px;
  letter-spacing: 3px;
  padding: 13px 28px;
  cursor: pointer;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
  opacity: 0;
  transition: opacity 0.4s, color 0.2s, background 0.2s;
}
.boot-cta.visible { opacity: 1; }
.boot-cta::after {
  content: '';
  position: absolute; inset: 0;
  background: var(--accent);
  opacity: 0;
  transition: opacity 0.2s;
}
.boot-cta:hover::after { opacity: 0.08; }
.boot-cta:active { background: var(--accent); color: var(--bg); }

.boot-cta-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--accent);
  animation: dotPulse 1.2s ease-in-out infinite;
}
@keyframes dotPulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:0.3;transform:scale(0.7)} }

/* ============================================================
   SIM SCREEN LAYOUT
   ============================================================ */
#sim-screen {
  background: var(--bg);
}

/* TOP BAR */
.top-bar {
  height: 46px;
  flex-shrink: 0;
  display: flex;
  align-items: stretch;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
  z-index: 10;
}

.tb-cell {
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 0 11px;
  border-right: 1px solid var(--border);
  gap: 3px;
  min-width: 0;
}
.tb-cell:last-child { border-right: none; margin-left: auto; }

.tb-label {
  font-size: 7px;
  letter-spacing: 2.5px;
  color: var(--text-dim);
  text-transform: uppercase;
}
.tb-value {
  font-size: 11px;
  color: var(--text-hi);
  white-space: nowrap;
}

.eb-row { display: flex; align-items: center; gap: 7px; }
.eb-track {
  width: 68px; height: 4px;
  background: var(--border);
  position: relative;
  overflow: hidden;
}
.eb-fill {
  height: 100%;
  background: var(--accent);
  transition: width 0.4s, background 0.4s;
}
.eb-pct {
  font-size: 11px;
  color: var(--text-hi);
  min-width: 30px;
}

.sig-dot {
  display: inline-block;
  width: 5px; height: 5px;
  border-radius: 50%;
  background: var(--accent);
  margin-right: 5px;
  animation: sigPulse 2.4s ease-in-out infinite;
}
@keyframes sigPulse { 0%,100%{opacity:1} 50%{opacity:0.25} }

.storm-badge {
  display: none;
  align-items: center;
  gap: 6px;
  font-size: 9px;
  letter-spacing: 2px;
  color: var(--amber);
  border: 1px solid var(--amber-dk);
  padding: 2px 8px;
  margin: auto 10px;
  animation: stormFlash 0.9s step-end infinite;
}
.storm-badge.visible { display: flex; }
@keyframes stormFlash { 0%,100%{opacity:1} 50%{opacity:0.4} }

/* VIEWPORT */
.viewport {
  flex: 1;
  position: relative;
  overflow: hidden;
  background: #030609;
  min-height: 0;
}

/* Three.js canvas — replaces terrain-canvas */
#threejs-canvas {
  position: absolute; inset: 0;
  width: 100%; height: 100%;
  display: none;
}

/* Legacy 2D canvas — hidden once 3D initialises */
canvas#terrain-canvas {
  position: absolute; inset: 0;
  width: 100%; height: 100%;
}

/* Terrain data overlay */
.terrain-overlay {
  position: absolute;
  top: 12px; left: 12px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  z-index: 5;
}
.to-name {
  font-size: 11px;
  letter-spacing: 1.5px;
  color: var(--text-hi);
}
.to-row {
  font-size: 9px;
  color: var(--text-dim);
  display: flex;
  gap: 6px;
}
.to-row span { color: var(--amber); }

/* Node proximity pill */
.node-pill {
  position: absolute;
  top: 12px;
  left: 50%; transform: translateX(-50%);
  font-size: 9px;
  letter-spacing: 2.5px;
  color: var(--accent);
  border: 1px solid var(--accent-dk);
  background: rgba(0,20,30,0.85);
  padding: 5px 14px;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.35s;
  pointer-events: none;
  z-index: 5;
}
.node-pill.visible { opacity: 1; }

/* Latency transmit banner */
.lat-banner {
  position: absolute;
  bottom: 12px; left: 50%; transform: translateX(-50%);
  font-size: 9px;
  letter-spacing: 3px;
  color: var(--accent);
  background: rgba(3,5,10,0.9);
  border: 1px solid var(--border-hi);
  padding: 5px 16px;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
  z-index: 5;
}
.lat-banner.visible { opacity: 1; }

/* Toast log */
.toast-log {
  position: absolute;
  bottom: 12px; left: 12px;
  font-size: 9px;
  color: var(--text-dim);
  letter-spacing: 1px;
  max-width: 60%;
  z-index: 5;
}

/* Validation counter */
.val-chip {
  position: absolute;
  bottom: 12px; right: 12px;
  font-size: 9px;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  z-index: 5;
}
.val-chip span { color: var(--green); }

/* Dust storm veil */
.storm-veil {
  position: absolute; inset: 0;
  background: rgba(100,50,0,0.0);
  pointer-events: none;
  transition: background 1.5s;
  z-index: 4;
}
.storm-veil.active { background: rgba(100,50,0,0.12); }

/* Heartbeat veil */
.hb-veil {
  position: absolute; inset: 0;
  pointer-events: none;
  box-shadow: inset 0 0 80px rgba(255,58,58,0);
  transition: box-shadow 0.5s;
  z-index: 4;
}
.hb-veil.pulse {
  animation: hbPulse 1.3s ease-in-out infinite;
}
@keyframes hbPulse {
  0%,100% { box-shadow: inset 0 0 80px rgba(255,58,58,0); }
  50%      { box-shadow: inset 0 0 80px rgba(255,58,58,0.18); }
}

/* Solar glow */
.solar-glow {
  position: fixed; inset: 0; pointer-events: none; z-index: 50;
  box-shadow: inset 0 0 80px rgba(255,170,0,0);
  transition: box-shadow 2s;
}
.solar-glow.active {
  box-shadow: inset 0 0 80px rgba(255,170,0,0.07);
}

/* Rover mast SVG */
.rover-wrap {
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 130px;
  animation: mastSway 3.5s ease-in-out infinite;
  z-index: 6;
}
@keyframes mastSway {
  0%,100% { transform: translateX(-50%) rotate(-0.25deg); }
  50%      { transform: translateX(-50%) rotate(0.25deg); }
}

/* 3D direction indicator overlay */
.dir-indicator {
  position: absolute;
  top: 12px; right: 12px;
  font-size: 8px;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  border: 1px solid var(--border);
  padding: 4px 8px;
  z-index: 5;
  display: none;
}
.dir-indicator.visible { display: block; }

/* CONTROLS AREA */
.controls-wrap {
  height: 38%;
  flex-shrink: 0;
  display: flex;
  border-top: 1px solid var(--border);
  min-height: 155px;
  max-height: 220px;
}

/* CAM FEED PANEL */
.cam-panel {
  width: 50%;
  background: var(--panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  padding: 10px;
  gap: 7px;
}
.panel-label {
  font-size: 7px;
  letter-spacing: 2.5px;
  color: var(--text-dim);
  text-transform: uppercase;
  display: flex;
  align-items: center;
  gap: 5px;
}

.cam-screen {
  flex: 1;
  background: #020408;
  border: 1px solid var(--border);
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 0;
}
.cam-screen::before,
.cam-screen::after {
  content: '';
  position: absolute;
  background: rgba(0,200,255,0.12);
  pointer-events: none;
}
.cam-screen::before { width: 1px; height: 100%; left: 50%; }
.cam-screen::after  { height: 1px; width: 100%;  top: 50%; }

.cam-data {
  font-size: 8px;
  color: rgba(0,200,255,0.35);
  line-height: 1.9;
  text-align: center;
  z-index: 1;
}

.scan-sweep {
  position: absolute; inset: 0;
  background: linear-gradient(to bottom, transparent, rgba(0,200,255,0.07) 50%, transparent);
  transform: translateY(-100%);
  opacity: 0;
  pointer-events: none;
}
.scan-sweep.active {
  opacity: 1;
  animation: sweepDown 1.6s linear infinite;
}
@keyframes sweepDown {
  from { transform: translateY(-100%); }
  to   { transform: translateY(100%); }
}

.sys-rows {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.sys-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 8.5px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 2px;
}
.sys-key { color: var(--text-dim); }
.sys-val { color: var(--text-hi); }
.sys-val.warn { color: var(--amber); }
.sys-val.ok   { color: var(--green); }
.sys-val.bad  { color: var(--red); }

/* SCAN BUTTON */
.scan-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  background: none;
  border: 1px solid var(--border-hi);
  color: var(--text-dim);
  font-family: var(--mono);
  font-size: 9px;
  letter-spacing: 2px;
  padding: 8px;
  text-transform: uppercase;
  cursor: not-allowed;
  transition: all 0.2s;
}
.scan-btn.ready {
  border-color: var(--accent);
  color: var(--accent);
  cursor: pointer;
  animation: scanReady 1.8s ease-in-out infinite;
}
.scan-btn.ready:active { background: rgba(0,200,255,0.1); }
@keyframes scanReady {
  0%,100%{ box-shadow: 0 0 0 rgba(0,200,255,0); }
  50%    { box-shadow: 0 0 12px rgba(0,200,255,0.2); }
}

/* MOVE PAD PANEL */
.move-panel {
  width: 50%;
  background: var(--panel);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 10px;
  position: relative;
}
.move-panel-label {
  position: absolute;
  top: 10px; left: 10px;
  font-size: 7px;
  letter-spacing: 2.5px;
  color: var(--text-dim);
}

/* D-PAD */
.dpad-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}
.dpad-row {
  display: flex;
  gap: 4px;
}
.dir-btn {
  width: 44px; height: 38px;
  background: var(--surface);
  border: 1px solid var(--border-hi);
  color: var(--text-dim);
  font-family: var(--mono);
  font-size: 9px;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.12s;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}
.dir-btn::after {
  content: '';
  position: absolute; inset: 0;
  background: var(--accent);
  opacity: 0;
  transition: opacity 0.12s;
}
.dir-btn:not(.ghost):hover { border-color: var(--text-dim); color: var(--text); }
.dir-btn:not(.ghost):active::after { opacity: 0.15; }
.dir-btn:not(.ghost):active { border-color: var(--accent); color: var(--accent); }
.dir-btn.ghost { background: transparent; border-color: transparent; cursor: default; pointer-events: none; }
.dir-btn.lit { border-color: var(--accent); color: var(--accent); }

.rover-state-badge {
  font-size: 8px;
  letter-spacing: 2px;
  color: var(--text-dim);
  border: 1px solid var(--border);
  padding: 3px 10px;
}
.rover-state-badge.moving { color: var(--accent); border-color: var(--accent-dk); }
.rover-state-badge.scanning { color: var(--amber); border-color: var(--amber-dk); }

/* ============================================================
   MODAL SYSTEM
   ============================================================ */
.modal-bg {
  position: fixed; inset: 0; z-index: 500;
  background: rgba(0,0,0,0.88);
  display: flex;
  align-items: flex-end;
  opacity: 0; pointer-events: none;
  transition: opacity 0.3s;
}
.modal-bg.open {
  opacity: 1; pointer-events: all;
}
.modal-card {
  width: 100%;
  background: var(--panel);
  border-top: 1px solid var(--border-hi);
  padding: 20px 16px 28px;
  max-height: 80vh;
  overflow-y: auto;
  transform: translateY(16px);
  transition: transform 0.3s;
}
.modal-bg.open .modal-card { transform: translateY(0); }

.modal-tag {
  font-size: 7px;
  letter-spacing: 3px;
  color: var(--text-dim);
  text-transform: uppercase;
  margin-bottom: 10px;
}
.modal-title {
  font-family: var(--display);
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 1px;
  color: var(--text-hi);
  margin-bottom: 6px;
}
.modal-sub {
  font-size: 9px;
  color: var(--amber);
  margin-bottom: 16px;
  line-height: 1.8;
}
.modal-divider { height: 1px; background: var(--border); margin: 14px 0; }

.q-text {
  font-size: 12px;
  color: var(--text);
  line-height: 1.7;
  margin-bottom: 14px;
}

.choices { display: flex; flex-direction: column; gap: 7px; }
.c-btn {
  background: var(--surface);
  border: 1px solid var(--border-hi);
  color: var(--text-dim);
  font-family: var(--mono);
  font-size: 10px;
  padding: 11px 14px;
  text-align: left;
  cursor: pointer;
  transition: all 0.15s;
  position: relative;
  line-height: 1.5;
}
.c-btn::before {
  content: '';
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 2px;
  background: var(--accent);
  transform: scaleY(0);
  transition: transform 0.15s;
}
.c-btn:hover { border-color: var(--border-hi); color: var(--text); }
.c-btn:hover::before { transform: scaleY(0.4); }
.c-btn.selected { border-color: var(--accent); color: var(--accent); }
.c-btn.selected::before { transform: scaleY(1); }
.c-btn.correct { border-color: var(--green); color: var(--green); background: rgba(0,232,122,0.04); }
.c-btn.wrong   { border-color: var(--red);   color: var(--red);   background: rgba(255,58,58,0.04); }

.submit-btn {
  margin-top: 14px;
  width: 100%;
  background: none;
  border: 1px solid var(--accent);
  color: var(--accent);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 3px;
  padding: 13px;
  cursor: pointer;
  text-transform: uppercase;
  transition: background 0.2s;
  display: none;
}
.submit-btn:hover { background: rgba(0,200,255,0.06); }
.submit-btn:active { background: rgba(0,200,255,0.15); }

.result-stats {
  display: flex;
  gap: 8px;
  margin: 14px 0;
}
.r-stat {
  flex: 1;
  border: 1px solid var(--border);
  padding: 10px 6px;
  text-align: center;
}
.r-stat-val {
  display: block;
  font-size: 16px;
  color: var(--accent);
  margin-bottom: 3px;
  font-family: var(--display);
  font-weight: 400;
}
.r-stat-val.neg { color: var(--red); }
.r-stat-val.amber { color: var(--amber); }
.r-stat-label {
  font-size: 7px;
  letter-spacing: 1.5px;
  color: var(--text-dim);
}

.continue-btn {
  margin-top: 12px;
  width: 100%;
  background: none;
  border: 1px solid var(--border-hi);
  color: var(--text);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 2px;
  padding: 13px;
  cursor: pointer;
  transition: background 0.2s;
}
.continue-btn:hover { background: rgba(255,255,255,0.03); }

#fail-modal .modal-card { border-top-color: var(--red); }
.fail-title {
  font-family: var(--display);
  font-size: 18px;
  font-weight: 700;
  color: var(--red);
  letter-spacing: 3px;
  text-align: center;
  margin: 10px 0 6px;
  animation: failFlicker 0.15s step-end infinite;
}
@keyframes failFlicker { 0%,100%{opacity:1} 50%{opacity:0.8} }
.fail-sub {
  text-align: center;
  font-size: 9px;
  color: var(--text-dim);
  letter-spacing: 1.5px;
  margin-bottom: 20px;
}
.fail-btn {
  width: 100%;
  background: none;
  border: 1px solid var(--red);
  color: var(--red);
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 3px;
  padding: 13px;
  cursor: pointer;
  transition: background 0.2s;
}
.fail-btn:hover { background: rgba(255,58,58,0.08); }

.modal-top-row {
  display: flex; align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}
.difficulty-badge {
  font-size: 7px; letter-spacing: 2px;
  padding: 3px 8px; flex-shrink: 0;
  border: 1px solid var(--border-hi);
  color: var(--text-dim); text-transform: uppercase;
}
.diff-critical    { border-color: #5a0a0a; color: var(--red); }
.diff-precision   { border-color: var(--accent-dk); color: var(--accent); }
.diff-discovery   { border-color: #1a3a10; color: var(--green); }
.diff-engineering { border-color: var(--amber-dk); color: var(--amber); }
.diff-calibration { border-color: var(--accent-dk); color: var(--accent); }
.diff-telemetry   { border-color: #203020; color: #80c860; }
.diff-mobility    { border-color: var(--amber-dk); color: var(--amber); }
.diff-methodology { border-color: var(--accent-dk); color: var(--accent); }
.diff-navigation  { border-color: #1a3a10; color: var(--green); }
.explanation-box {
  margin-top: 12px;
  border: 1px solid var(--border-hi);
  background: rgba(0,200,255,0.025);
  padding: 10px 12px;
}
.exp-label {
  font-size: 7px; letter-spacing: 2.5px;
  color: var(--accent); margin-bottom: 6px;
}
.exp-text {
  font-size: 10px; color: var(--text); line-height: 1.8;
}

.hidden { display: none !important; }

</style>
</head>
<body>

<div id="overlay-scanlines"></div>
<div id="overlay-vignette"></div>
<div id="overlay-grain"></div>
<div class="solar-glow" id="solar-glow"></div>

<!-- ============================================================
     BOOT SCREEN
     ============================================================ -->
<div class="screen active" id="boot-screen">
  <div class="boot-header">ISRO · DSN RELAY · HEX-01</div>
  <div class="boot-log" id="boot-log"></div>
  <div class="boot-progress">
    <div class="boot-progress-fill" id="boot-progress-fill"></div>
  </div>
  <button class="boot-cta" id="boot-cta" onclick="initiateControl()">
    <span class="boot-cta-dot"></span>
    INITIATE CONTROL
  </button>
</div>

<!-- ============================================================
     SIM SCREEN
     ============================================================ -->
<div class="screen" id="sim-screen">

  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="tb-cell">
      <div class="tb-label">Energy Reserve</div>
      <div class="eb-row">
        <div class="eb-track"><div class="eb-fill" id="eb-fill" style="width:84%"></div></div>
        <span class="eb-pct" id="energy-text">84%</span>
      </div>
    </div>
    <div class="tb-cell">
      <div class="tb-label">Signal Latency</div>
      <div class="tb-value" id="latency-text"><span class="sig-dot"></span>12m 30s</div>
    </div>
    <div class="tb-cell">
      <div class="tb-label">Sol / State</div>
      <div class="tb-value" id="sol-text">SOL 127</div>
    </div>
    <div class="storm-badge" id="storm-badge">
      <span>⚡</span> DUST STORM
    </div>
    <div class="tb-cell">
      <div class="tb-label">Validation</div>
      <div class="tb-value" id="val-text" style="color:var(--green)">0 pts</div>
    </div>
  </div>

  <!-- VIEWPORT -->
  <div class="viewport" id="viewport">
    <!-- Three.js canvas (3D) -->
    <canvas id="threejs-canvas"></canvas>
    <!-- Legacy 2D canvas (fallback) -->
    <canvas id="terrain-canvas"></canvas>

    <!-- Rover mast SVG -->
    <div class="rover-wrap">
      <svg viewBox="0 0 130 210" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="59" y="65" width="12" height="130" fill="#0e1e2c"/>
        <rect x="61" y="65" width="8" height="130" fill="#0f2030"/>
        <rect x="59" y="85"  width="12" height="2" fill="#162838"/>
        <rect x="59" y="110" width="12" height="2" fill="#162838"/>
        <rect x="59" y="135" width="12" height="2" fill="#162838"/>
        <rect x="59" y="160" width="12" height="2" fill="#162838"/>
        <rect x="36" y="48" width="58" height="30" rx="3" fill="#0d1c2a"/>
        <rect x="38" y="50" width="54" height="26" rx="2" fill="#091422"/>
        <circle cx="52" cy="63" r="9"  fill="#070f1a"/>
        <circle cx="52" cy="63" r="7"  fill="#080e16"/>
        <circle cx="52" cy="63" r="4.5" fill="#040a10"/>
        <circle cx="50" cy="61" r="1.5" fill="#1a3050" opacity="0.7"/>
        <circle cx="78" cy="63" r="9"  fill="#070f1a"/>
        <circle cx="78" cy="63" r="7"  fill="#080e16"/>
        <circle cx="78" cy="63" r="4.5" fill="#040a10"/>
        <circle cx="76" cy="61" r="1.5" fill="#1a3050" opacity="0.7"/>
        <line x1="65" y1="48" x2="65" y2="26" stroke="#162838" stroke-width="1.5"/>
        <circle cx="65" cy="24" r="3.5" fill="#0d1c2a" stroke="#00c8ff" stroke-width="0.6" opacity="0.6"/>
        <rect x="94" y="53" width="22" height="4" rx="1" fill="#0e1e2c"/>
        <circle cx="117" cy="55" r="4.5" fill="#0d1c2a" stroke="#162838" stroke-width="1"/>
        <circle cx="90" cy="55" r="2.2" fill="#00c8ff" opacity="0.5" id="status-led"/>
      </svg>
    </div>

    <!-- Terrain data -->
    <div class="terrain-overlay">
      <div class="to-name" id="to-name">BASALTIC FLATS</div>
      <div class="to-row">CMPLX <span id="to-cmplx">2.1</span></div>
      <div class="to-row">SLIP  <span id="to-slip">2%</span></div>
    </div>

    <!-- Direction indicator (3D mode) -->
    <div class="dir-indicator" id="dir-indicator">HDG: N</div>

    <!-- Node pill -->
    <div class="node-pill" id="node-pill">◈ GEO-NODE IN PROXIMITY</div>

    <!-- Latency banner -->
    <div class="lat-banner" id="lat-banner">TRANSMITTING COMMAND…</div>

    <!-- Toast -->
    <div class="toast-log" id="toast-log">SYS: AWAITING COMMAND</div>

    <!-- Validation chip -->
    <div class="val-chip">TILES <span id="val-chip-val">0</span></div>

    <!-- Storm veil -->
    <div class="storm-veil" id="storm-veil"></div>

    <!-- Heartbeat veil -->
    <div class="hb-veil" id="hb-veil"></div>
  </div>

  <!-- CONTROLS -->
  <div class="controls-wrap">

    <!-- CAM FEED -->
    <div class="cam-panel">
      <div class="panel-label"><span class="sig-dot" style="width:4px;height:4px"></span>NAVCAM_L · FEED</div>
      <div class="cam-screen">
        <div class="cam-data" id="cam-data">FOCAL 50mm<br>ISO 800<br>EXP 1/250</div>
        <div class="scan-sweep" id="scan-sweep"></div>
      </div>
      <div class="sys-rows" id="sys-rows">
        <div class="sys-row"><span class="sys-key">ROVER</span><span class="sys-val ok" id="sr-state">IDLE</span></div>
        <div class="sys-row"><span class="sys-key">TEMP</span> <span class="sys-val" id="sr-temp">-54.2°C</span></div>
        <div class="sys-row"><span class="sys-key">SOLAR</span><span class="sys-val ok" id="sr-solar">OPTIMAL</span></div>
      </div>
      <button class="scan-btn" id="scan-btn" onclick="startScan()">
        ◈ INITIATE APXS SCAN
      </button>
    </div>

    <!-- MOVE PAD -->
    <div class="move-panel">
      <div class="move-panel-label">MOVE CONTROL · 8-DIR</div>
      <div class="dpad-wrap">
        <div class="dpad-row">
          <button class="dir-btn" id="d-NW" onclick="move('NW')">NW</button>
          <button class="dir-btn" id="d-N"  onclick="move('N')"> N </button>
          <button class="dir-btn" id="d-NE" onclick="move('NE')">NE</button>
        </div>
        <div class="dpad-row">
          <button class="dir-btn" id="d-W"  onclick="move('W')"> W </button>
          <button class="dir-btn" id="d-scan" onclick="startScan()" style="font-size:7px;letter-spacing:1px;color:var(--text-dim)">SCN</button>
          <button class="dir-btn" id="d-E"  onclick="move('E')"> E </button>
        </div>
        <div class="dpad-row">
          <button class="dir-btn" id="d-SW" onclick="move('SW')">SW</button>
          <button class="dir-btn" id="d-S"  onclick="move('S')"> S </button>
          <button class="dir-btn" id="d-SE" onclick="move('SE')">SE</button>
        </div>
      </div>
      <div class="rover-state-badge" id="rsb">IDLE</div>
    </div>

  </div>
</div>

<!-- ============================================================
     CHALLENGE MODAL
     ============================================================ -->
<div class="modal-bg" id="challenge-modal">
  <div class="modal-card">
    <div class="modal-top-row">
      <div class="modal-tag" id="c-qid">◈ Q_001 · APXS · MSL</div>
      <div class="difficulty-badge" id="c-diff">CRITICAL</div>
    </div>
    <div class="modal-title" id="c-title">Surface Spectral Analysis</div>
    <div class="modal-sub" id="c-sub">Spectrometer data indicates high Fe₂O₃ concentration.</div>
    <div class="modal-divider"></div>
    <div class="q-text" id="q-text">Select analysis hypothesis:</div>
    <div class="choices" id="choices-div"></div>
    <div class="explanation-box" id="explanation-box" style="display:none">
      <div class="exp-label">◈ SCIENTIFIC BASIS</div>
      <div class="exp-text" id="exp-text"></div>
    </div>
    <button class="submit-btn" id="submit-btn" onclick="submitAnswer()">TRANSMIT ANALYSIS</button>
  </div>
</div>

<!-- ============================================================
     RESULT MODAL
     ============================================================ -->
<div class="modal-bg" id="result-modal">
  <div class="modal-card">
    <div class="modal-tag" id="r-tag">◈ TRANSMISSION LOGGED</div>
    <div class="modal-title" id="r-title">Analysis Confirmed</div>
    <div class="modal-sub" id="r-sub"></div>
    <div class="result-stats">
      <div class="r-stat">
        <span class="r-stat-val" id="r-energy">+8%</span>
        <div class="r-stat-label">ENERGY DELTA</div>
      </div>
      <div class="r-stat">
        <span class="r-stat-val" id="r-val">+10pts</span>
        <div class="r-stat-label">VALIDATION</div>
      </div>
      <div class="r-stat">
        <span class="r-stat-val" id="r-lat">—</span>
        <div class="r-stat-label">LATENCY DELTA</div>
      </div>
    </div>
    <button class="continue-btn" onclick="closeResult()">CONTINUE MISSION</button>
  </div>
</div>

<!-- ============================================================
     ENERGY FAIL MODAL
     ============================================================ -->
<div class="modal-bg" id="fail-modal">
  <div class="modal-card">
    <div class="modal-tag">✕ CRITICAL SYSTEM ALERT</div>
    <div class="fail-title">ENERGY DEPLETED</div>
    <div class="fail-sub">ROVER HEX-01 OFFLINE · SOLAR RECOVERY REQUIRED</div>
    <button class="fail-btn" onclick="endSim()">END SIMULATION</button>
  </div>
</div>


<script>
/* ============================================================
   ENGINE — ALL ORIGINAL LOGIC PRESERVED VERBATIM
   ============================================================ */

const MISSION_CONFIG = {
  communications: {
    latency: { minMs: 240000, maxMs: 1440000, averageMs: 750000 },
    bandwidthKbps: { directToEarth: 0.5, orbiterRelay: 2000.0 }
  },
  powerSystems: {
    solar: { optimalGenerationWhPerSol: 900.0, dustStormMultiplier: 0.05, nightHeaterDrainWh: -150.0 }
  },
  locomotion: {
    maxSpeedCmPerSec: 4.16, maxSafeInclineDegrees: 30.0, baseEnergyDrainPerMove: 1.5
  },
  instruments: {
    apxs_spectrometer: { energyCostPct: 12.0, timeCostMinutes: 180.0 }
  }
};

const TERRAIN_DATABASE = [
  { id: "T_BASALTIC_FLATS",  name: "Basaltic Flats",  complexityIndex: 2.1, hazards: { slipProbability: 0.02, costMult: 1.0 } },
  { id: "T_REGOLITH_FIELD",  name: "Regolith Field",  complexityIndex: 4.5, hazards: { slipProbability: 0.15, costMult: 1.2 } },
  { id: "T_SCORIA_OUTCROP",  name: "Scoria Outcrop",  complexityIndex: 6.8, hazards: { slipProbability: 0.40, costMult: 1.8 } },
  { id: "T_SOFT_DUST_DRIFT", name: "Soft Dust Drift", complexityIndex: 8.5, hazards: { slipProbability: 0.85, costMult: 2.5 } }
];

const S = {
  energy: 84,
  validation: 0,
  roverState: 'IDLE',
  stormActive: false,
  currentTerrain: TERRAIN_DATABASE[0],
  playableLatencyMs: 1200,
  simLatencySeconds: MISSION_CONFIG.communications.latency.averageMs / 1000,
  nodeNearby: false,
  _lastDir: null
};

let loops = { ambient: null, solar: null, nodes: null };

const CHALLENGES = [
  {
    id: "Q_001", instrument: "APXS · MSL", difficulty: "CRITICAL",
    title: "APXS Lockup Anomaly — Tactical Mitigation",
    sub: "Telemetry shows instrument generating artificial counts at lowest energy channel only.",
    question: "During a long-duration APXS integration on Curiosity, the instrument has stopped recording real X-ray events and is only generating artificial counts at the lowest detectable energy channel — the \"lockup\" anomaly. What is the required tactical mitigation?",
    choices: [
      { text: "A) Increase the integration time to 5 hours to override the internal software buffer.", correct: false },
      { text: "B) Initiate a power cycle and split subsequent long integrations into two shorter sessions.", correct: true },
      { text: "C) Deploy the robotic arm to the basaltic calibration slab to reset the Curium-244 flux.", correct: false },
    ],
    explanation: "Power cycling clears the lockup state. Splitting subsequent integrations into shorter sessions prevents recurrence of the buffer overflow condition."
  },
  {
    id: "Q_002", instrument: "NavCam · MSL RSM", difficulty: "PRECISION",
    title: "NavCam Stereo Baseline — RSM Geometric Engine",
    sub: "Stereo pair used for ChemCam target distance calculation.",
    question: "A NavCam stereo pair on the MSL Remote Sensing Mast (RSM) is being used to calculate the distance to a rock target for ChemCam targeting. What is the fixed stereo baseline distance used by the simulator's geometric engine for this calculation?",
    choices: [
      { text: "A) 20.0 cm", correct: false },
      { text: "B) 42.4 cm", correct: true },
      { text: "C) 1.97 m", correct: false },
    ],
    explanation: "The MSL RSM NavCam stereo baseline is 42.4 cm. This fixed separation between the two camera eyes enables triangulation for accurate distance estimation to surface targets."
  },
  {
    id: "Q_003", instrument: "APXS · MSL", difficulty: "DISCOVERY",
    title: "2024 APXS Contact Analysis — Surprise Detection",
    sub: "Analysis on rock fractured by rover wheels. Spectra show never-before-seen element.",
    question: "In 2024, Curiosity's APXS performed a contact analysis on a rock recently fractured by the rover's wheels. The resulting spectra revealed a \"surprise discovery\" never before seen in pure form on Mars. What was the element detected?",
    choices: [
      { text: "A) Pure Magnesium", correct: false },
      { text: "B) Pure Sulfur crystals", correct: true },
      { text: "C) Pure Hematite", correct: false },
    ],
    explanation: "The fractured rock exposed pure sulfur crystals — the first time elemental sulfur had been detected in pure form on Mars."
  },
  {
    id: "Q_004", instrument: "NavCam · MSL", difficulty: "ENGINEERING",
    title: "NavCam Mounting Height — MSL Engineering Spec",
    sub: "Configuring boresight for high-resolution terrain context mosaic.",
    question: "You are configuring the NavCam boresight for a high-resolution terrain context mosaic. According to MSL engineering specifications, at what height is the upper primary NavCam pair mounted above the base of the rover wheels?",
    choices: [
      { text: "A) 1.10 m", correct: false },
      { text: "B) 1.99 m", correct: true },
      { text: "C) 0.85 m", correct: false },
    ],
    explanation: "The upper primary NavCam pair on MSL's Remote Sensing Mast is mounted at 1.99 m above the rover wheel base."
  },
  {
    id: "Q_005", instrument: "APXS · Chandrayaan-3 / PRL", difficulty: "CALIBRATION",
    title: "Pragyan APXS — Primary Calibration Target Elements",
    sub: "Characteristic X-ray emission analysis on lunar regolith.",
    question: "The Pragyan rover (Chandrayaan-3) APXS, developed by the Physical Research Laboratory (PRL), uses \"characteristic X-rays\" to identify elements. Which specific group of elements is the instrument primarily calibrated to quantify in the lunar soil?",
    choices: [
      { text: "A) Noble gases including Neon and Argon", correct: false },
      { text: "B) Major and minor elements such as Si, Mg, Al, Fe, Ca, and Ti", correct: true },
      { text: "C) Heavy radioactive isotopes only", correct: false },
    ],
    explanation: "The Pragyan APXS (PRL) is calibrated for major rock-forming elements: Silicon, Magnesium, Aluminum, Iron, Calcium, and Titanium."
  },
  {
    id: "Q_006", instrument: "Mobility · MSL", difficulty: "MOBILITY",
    title: "Rocker-Bogie Suspension — Primary Operational Advantage",
    sub: "Suspension design comparison: rocker-bogie vs. traditional spring systems.",
    question: "The rover's mobility system utilizes a 'rocker-bogie' suspension design rather than traditional springs. What is the primary operational advantage of this mechanical configuration when navigating rough Martian terrain?",
    choices: [
      { text: "A) It allows the rover to achieve higher top speeds on flat terrain like basaltic plains.", correct: false },
      { text: "B) It maintains relatively equal weight distribution on all six wheels while climbing obstacles larger than the wheel diameter.", correct: true },
      { text: "C) It physically lifts the main rover chassis to step over large boulders.", correct: false },
    ],
    explanation: "The rocker-bogie linkage is a passive mechanical system with no springs or actuators. When one side encounters an obstacle, the rocker pivots to redistribute load across all six wheels, maintaining traction and preventing tip-over on rocks exceeding wheel diameter. This is why Curiosity can climb 75 cm obstacles despite having no active suspension."
  },
  {
    id: "Q_007", instrument: "NavCam · Mobility", difficulty: "MOBILITY",
    title: "Rocker-Bogie Slip Monitoring — Instrument Objective",
    sub: "NavCam detects sudden increase in wheel sinkage.",
    question: "The \"rocker-bogie\" suspension system is visible in NavCam monitoring. If the NavCam detects a sudden increase in wheel sinkage, the operator must assess the \"slip\" risk. Which ISRO/NASA instrument objective specifically covers this monitoring?",
    choices: [
      { text: "A) Investigating landing sites at meter-scale resolution", correct: false },
      { text: "B) Mobility planning including wheel sinkage and obstruction analysis", correct: true },
      { text: "C) Atmospheric pressure monitoring for dust devil detection", correct: false },
    ],
    explanation: "NavCam mobility planning objectives specifically include wheel sinkage assessment and obstruction analysis."
  },
  {
    id: "Q_008", instrument: "APXS · Chandrayaan-3", difficulty: "CALIBRATION",
    title: "Pragyan APXS Calibration Plate — Target Materials",
    sub: "Known metallic calibration standards with well-characterised spectra mounted on rover.",
    question: "To ensure data integrity, the Pragyan APXS performs a calibration check before analyzing lunar soil. It uses known metallic calibration standards with well-characterised spectra mounted directly on the rover. Identify the correct calibration materials:",
    choices: [
      { text: "A) Gold, Silver, Platinum, and Nickel", correct: false },
      { text: "B) Stainless Steel, Copper, Titanium, and Aluminum", correct: true },
      { text: "C) Iron, Lead, Zinc, and Magnesium", correct: false },
    ],
    explanation: "The Pragyan APXS calibration plate uses Stainless Steel, Copper, Titanium, and Aluminum — materials with well-characterised X-ray fluorescence spectra. These standards allow the instrument to verify its gain and energy calibration before each lunar soil measurement, ensuring data integrity across the mission."
  },
  {
    id: "Q_009", instrument: "APXS · MSL Design", difficulty: "METHODOLOGY",
    title: "MSL APXS Dual Methodology — Analytical Techniques",
    sub: "Two integrated terrestrial methods in MSL APXS design.",
    question: "The APXS instrument utilizes a combination of two standard terrestrial methods to determine elemental chemistry. Which two methods are integrated into the MSL APXS design?",
    choices: [
      { text: "A) Laser-Induced Breakdown Spectroscopy (LIBS) and Mass Spectrometry", correct: false },
      { text: "B) Particle-Induced X-ray Emission (PIXE) and X-ray Fluorescence (XRF)", correct: true },
      { text: "C) Gamma Ray Spectroscopy and Neutron Activation Analysis", correct: false },
    ],
    explanation: "The MSL APXS integrates PIXE (using alpha particles from Curium-244) and XRF (using X-rays to excite fluorescence) — together covering elements from Na to Br."
  },
  {
    id: "Q_010", instrument: "NavCam · Chandrayaan-3", difficulty: "NAVIGATION",
    title: "Pragyan Dual NavCam — Primary Stereo Purpose",
    sub: "Two 1-megapixel cameras. Purpose of dual-camera configuration.",
    question: "Pragyan's NavCam system consists of two 1-megapixel cameras. What is the primary purpose of this specific dual-camera configuration for the ground control team on Earth?",
    choices: [
      { text: "A) To detect high-frequency radio interference from the Sun", correct: false },
      { text: "B) To generate 3D vision maps of the lunar surface for path planning", correct: true },
      { text: "C) To monitor the thermal degradation of the solar panels", correct: false },
    ],
    explanation: "The dual 1-MP NavCam configuration on Pragyan generates stereoscopic 3D terrain maps for safe traversal path planning."
  },
  {
    id: "Q_011", instrument: "Drill · MSL CheMin", difficulty: "ENGINEERING",
    title: "Feed Extended Drilling — Stalled Feed Motor Recovery",
    sub: "Drill feed motor stalled. Bit cannot extend past contact stabilizers.",
    question: "The drill's feed motor has stalled, preventing the bit from extending past the contact stabilizers. To continue pulverizing rock samples for the CheMin instrument, what novel technique must the autonomous engine execute?",
    choices: [
      { text: "A) Switch to the Dust Removal Tool to scrape the surface instead.", correct: false },
      { text: "B) Use \"Feed Extended Drilling\" by pushing the entire robotic arm forward using its internal force sensors to \"feel\" the rock.", correct: true },
      { text: "C) Fire the ChemCam laser continuously to blast a 2-inch core sample.", correct: false },
    ],
    explanation: "\"Feed Extended Drilling\" uses the robotic arm's own shoulder and elbow joints as the feed mechanism, pressing the bit into the rock by advancing the whole arm. Internal force sensors monitor contact load in real time, allowing the bit to pulverise material even when the dedicated feed motor has failed."
  },
  {
    id: "Q_012", instrument: "CheMin · MSL", difficulty: "DISCOVERY",
    title: "Gypsum vs. Anhydrite — X-ray Diffraction Identification",
    sub: "Powdered sample could be hydrated gypsum or anhydrous anhydrite.",
    question: "You need to distinguish whether a powdered sample is gypsum (which contains water) or anhydrite (which lacks water). Which MSL laboratory instrument uses X-ray diffraction to identify these specific mineral structures?",
    choices: [
      { text: "A) Alpha Particle X-ray Spectrometer (APXS)", correct: false },
      { text: "B) Chemistry and Mineralogy (CheMin)", correct: true },
      { text: "C) Radiation Assessment Detector (RAD)", correct: false },
    ],
    explanation: "CheMin uses X-ray diffraction (XRD) to resolve crystalline structures at the atomic lattice level. Because gypsum (CaSO₄·2H₂O) and anhydrite (CaSO₄) have identical elemental chemistry but distinct crystal structures, only XRD — not APXS elemental analysis — can distinguish them."
  },
  {
    id: "Q_013", instrument: "MAHLI · MSL", difficulty: "PRECISION",
    title: "MAHLI Micro-Imaging — Sub-Hair-Width Resolution",
    sub: "Geology team requires microscopic grain-scale imaging at 150 microns/pixel.",
    question: "The geology team needs a microscopic view of rock grains at a scale smaller than a human hair (150 microns/pixel). Which specific imager must be deployed directly against the rock surface to capture this data?",
    choices: [
      { text: "A) Mars Hand Lens Imager (MAHLI)", correct: true },
      { text: "B) Mast Camera (Mastcam)", correct: false },
      { text: "C) Rover Environmental Monitoring Station (REMS)", correct: false },
    ],
    explanation: "MAHLI is mounted on the turret at the end of the robotic arm and is designed to be placed within centimetres of rock surfaces. It can resolve features down to approximately 14 microns/pixel at minimum focus — far exceeding the 150 microns/pixel requirement. Mastcam cannot achieve this resolution from mast height."
  },
  {
    id: "Q_014", instrument: "Mobility · MSL", difficulty: "MOBILITY",
    title: "Terrain-Adaptive Wheel Speed — Loose Incline Slip Hazard",
    sub: "SLIP HAZARD: 15-degree incline of loose basaltic sand. Wheel sinkage risk.",
    question: "SLIP HAZARD: The rover is approaching a 15-degree incline composed of loose basaltic sand. To minimize the risk of the wheels sinking and experiencing excessive slip, which active mobility system should be utilized?",
    choices: [
      { text: "A) Terrain-Adaptive wheel speed control, which leverages rocker-bogie suspension angles to adjust individual wheel speeds.", correct: true },
      { text: "B) The High-Fidelity Traversability Analysis (HFTA) orbital mapping link.", correct: false },
      { text: "C) The Enhanced Autonomous Navigation (ENav) single-core kinematic settling sequence.", correct: false },
    ],
    explanation: "Terrain-adaptive wheel speed control monitors the rocker-bogie suspension articulation rates as a proxy for slip. When slip exceeds threshold on an incline, it reduces torque to the most-embedded wheels and redistributes drive effort — preventing the digging-in failure mode that destroyed several of Spirit's wheels."
  },
  {
    id: "Q_015", instrument: "Locomotion · Legged Rover", difficulty: "MOBILITY",
    title: "Cost of Transport Optimisation — Crater Wall Locomotion Strategy",
    sub: "[ RESEARCH-BASED LOCOMOTION STRATEGY FOR FUTURE SYSTEMS ] Quadruped on steep loose crater wall.",
    question: "[ RESEARCH-BASED LOCOMOTION STRATEGY FOR FUTURE SYSTEMS ] You are testing a quadruped (legged) rover on a steep, loose crater wall. To minimize the energetic Cost of Transport (CoT) and maintain stability, what transition should the locomotion engine trigger based on slip predictions?",
    choices: [
      { text: "A) Switch from a walking gait to a torso-based sliding locomotion.", correct: true },
      { text: "B) Switch to a dynamic jumping gait to clear the loose regolith.", correct: false },
      { text: "C) Deploy an explosive tethered penetrator to winch up the slope.", correct: false },
    ],
    explanation: "On very steep, loose slopes where limb thrust produces more slip than forward progress, torso-based sliding (controlled descent or lateral traversal using body contact and drag) has a lower energetic Cost of Transport than any legged gait. Research on Boston Dynamics-style quadrupeds on Mars analogue terrain confirms this transition minimises both energy expenditure and fall risk."
  },
  {
    id: "Q_016", instrument: "REMS · MSL", difficulty: "DISCOVERY",
    title: "Dust Storm Thermal Inversion — Nighttime Temperature Paradox",
    sub: "Global dust storm active. Atmospheric opacity tau = 10.8.",
    question: "A massive, global dust storm is active, and the atmospheric opacity (tau) has spiked to 10.8. Counterintuitively, what happens to the surface temperature during the Martian night compared to clear conditions?",
    choices: [
      { text: "A) It drops to cryogenic extremes due to the lack of daytime sunlight.", correct: false },
      { text: "B) It stays warmer than usual because the atmospheric dust acts as an insulating blanket, trapping heat.", correct: true },
      { text: "C) It fluctuates rapidly, causing thermal short-circuits in the NavCams.", correct: false },
    ],
    explanation: "Suspended dust particles absorb and re-emit infrared radiation in all directions. At night, this creates a greenhouse-like blanketing effect that reduces the rate of radiative cooling from the surface. REMS data from the 2018 global dust storm confirmed that Gale Crater surface temperatures were measurably warmer at night than during preceding clear-sky sols."
  },
  {
    id: "Q_017", instrument: "RAD · MSL", difficulty: "CRITICAL",
    title: "Radiation Assessment Detector — Cosmic Ray & Neutron Flux",
    sub: "Human mission hazard evaluation. Secondary neutrons + GCR data required.",
    question: "To evaluate the hazard level for future human missions, you must pull data on the secondary neutrons and galactic cosmic radiation hitting the rover's chassis. Which instrument provides this critical data stream?",
    choices: [
      { text: "A) Dynamic Albedo of Neutrons (DAN)", correct: false },
      { text: "B) Radiation Assessment Detector (RAD)", correct: true },
      { text: "C) Chemistry and Camera complex (ChemCam)", correct: false },
    ],
    explanation: "RAD is MSL's dedicated radiation monitor, measuring energetic particle radiation — including galactic cosmic rays (GCRs), solar energetic particles (SEPs), and secondary neutrons and charged particles produced by GCR interactions with the Martian atmosphere and soil. DAN measures thermal and epithermal neutrons specifically to detect subsurface hydrogen/water, not the full cosmic radiation environment."
  },
  {
    id: "Q_018", instrument: "Telecom · MRO UHF Relay", difficulty: "TELEMETRY",
    title: "UHF Orbiter Relay — Maximising Downlink Data Rate",
    sub: "X-band direct-to-Earth capping at 32 kbps. 3D photogrammetry dataset pending.",
    question: "The rover needs to downlink a massive 3D photogrammetry dataset. The Direct-to-Earth X-band rate is capping at 32,000 bits per second. How do you maximize your data rate up to 2 million bits per second?",
    choices: [
      { text: "A) Wait for Earth-Mars opposition to physically decrease the radio transit time.", correct: false },
      { text: "B) Relay the data via UHF to a passing satellite like the Mars Reconnaissance Orbiter (MRO).", correct: true },
      { text: "C) Switch the High-Gain Antenna transmission format to a compressed S-band signal.", correct: false },
    ],
    explanation: "MRO's ELECTRA UHF transceiver supports data rates up to 2 Mbps over short-range UHF links to the rover during an overpass window. The rover uplinks to MRO via UHF, and MRO then relays the data to Earth via its own high-gain X-band antenna at rates far exceeding direct-to-Earth rover capability. Opposition affects light-time delay, not maximum link rate."
  },
  {
    id: "Q_019", instrument: "Fault Protection · MSL", difficulty: "CRITICAL",
    title: "Solar Conjunction Fault Mode — 14-Day Autonomous Protocol",
    sub: "Superior solar conjunction. Sun blocking direct Earth line-of-sight.",
    question: "Mars is entering a superior solar conjunction, meaning the sun is blocking the direct line of sight to Earth. What autonomous fault mode protocol must the rover execute for the next 14 days?",
    choices: [
      { text: "A) Suspend all driving and active robotic arm science, running only basic health checks and executing pre-uploaded commands.", correct: true },
      { text: "B) Broadcast high-power beacon pings blindly into the solar corona until the Deep Space Network (DSN) acknowledges.", correct: false },
      { text: "C) Reroute all telemetry through the lunar orbital gateway to bypass the sun.", correct: false },
    ],
    explanation: "During solar conjunction, the Sun's corona introduces unacceptable noise and signal distortion on all radio frequencies used for Mars communication. JPL's standard protocol suspends all commands requiring real-time feedback (driving, arm science) for the conjunction period — approximately 14 days. Pre-uplinked \"conjunction keep-alive\" sequences run basic health maintenance autonomously."
  },
  {
    id: "Q_020", instrument: "MMRTG · Thermal", difficulty: "ENGINEERING",
    title: "MMRTG Waste Heat — Warm Electronics Box Thermal Management",
    sub: "Freezing Martian night. Must maintain computer temperature without battery drain.",
    question: "Your rover uses a Multi-Mission Radioisotope Thermoelectric Generator (MMRTG). During the freezing Martian night, how does the rover maintain its internal computer temperatures without draining precious battery reserves?",
    choices: [
      { text: "A) It diverts excess thermal energy (heat) directly from the MMRTG into the Warm Electronics Box (WEB).", correct: true },
      { text: "B) It uses the mechanical friction of spinning the suspended wheels to generate internal heat.", correct: false },
      { text: "C) It ignites small, localized pockets of hydrazine propellant in the chassis.", correct: false },
    ],
    explanation: "The MMRTG generates approximately 2,000 watts of thermal energy as a by-product of Plutonium-238 decay, but converts only ~110 watts of that to electricity. The remaining waste heat is deliberately routed through the rover's fluid loop into the Warm Electronics Box (WEB), passively keeping avionics above −40°C at night — at zero battery cost."
  }
];
let challengeIdx = 0;
let selectedChoiceIdx = null;

/* ── LEGACY 2D TERRAIN (FALLBACK) ────────────────────────── */
let canvas2d, ctx2d;
let tx = 0, ty = 0;

function initCanvas2d() {
  canvas2d = document.getElementById('terrain-canvas');
  const vp = document.getElementById('viewport');
  canvas2d.width  = vp.offsetWidth;
  canvas2d.height = vp.offsetHeight;
  window.addEventListener('resize', () => {
    canvas2d.width  = vp.offsetWidth;
    canvas2d.height = vp.offsetHeight;
  });
}

function drawTerrain2d() {
  if (!ctx2d) { ctx2d = canvas2d.getContext('2d'); }
  const w = canvas2d.width, h = canvas2d.height;
  ctx2d.clearRect(0, 0, w, h);

  const sky = ctx2d.createLinearGradient(0, 0, 0, h * 0.48);
  sky.addColorStop(0, '#060204');
  sky.addColorStop(1, '#180a06');
  ctx2d.fillStyle = sky;
  ctx2d.fillRect(0, 0, w, h * 0.48);

  const hg = ctx2d.createRadialGradient(w/2, h*0.46, 0, w/2, h*0.46, w*0.7);
  hg.addColorStop(0, 'rgba(160,60,10,0.1)');
  hg.addColorStop(1, 'rgba(0,0,0,0)');
  ctx2d.fillStyle = hg;
  ctx2d.fillRect(0, 0, w, h);

  const grd = ctx2d.createLinearGradient(0, h*0.46, 0, h);
  grd.addColorStop(0, '#1c0e07');
  grd.addColorStop(0.4, '#160b06');
  grd.addColorStop(1, '#0e0704');
  ctx2d.fillStyle = grd;
  ctx2d.fillRect(0, h*0.46, w, h*0.54);

  const ridge = ctx2d.createLinearGradient(0, h*0.43, 0, h*0.52);
  ridge.addColorStop(0, '#2a1508');
  ridge.addColorStop(1, '#160b05');
  ctx2d.fillStyle = ridge;
  ctx2d.beginPath();
  ctx2d.moveTo(0, h);
  const pts = 24;
  for (let i = 0; i <= pts; i++) {
    const xp = (i / pts) * w;
    const phase = xp / w * 6.28 + tx * 0.008;
    const yp = h * 0.47 - Math.sin(phase) * 9 - Math.cos(phase * 2.3) * 5;
    if (i === 0) ctx2d.moveTo(xp, yp); else ctx2d.lineTo(xp, yp);
  }
  ctx2d.lineTo(w, h); ctx2d.lineTo(0, h);
  ctx2d.closePath(); ctx2d.fill();

  const rocks = [
    { bx: 0.08, by: 0.62, rw: 0.055, rh: 0.038, phase: 1.0 },
    { bx: 0.22, by: 0.59, rw: 0.038, rh: 0.028, phase: 2.1 },
    { bx: 0.41, by: 0.66, rw: 0.072, rh: 0.048, phase: 3.2 },
    { bx: 0.60, by: 0.61, rw: 0.030, rh: 0.022, phase: 0.7 },
    { bx: 0.74, by: 0.70, rw: 0.048, rh: 0.034, phase: 4.1 },
    { bx: 0.88, by: 0.58, rw: 0.080, rh: 0.052, phase: 5.2 },
    { bx: 0.30, by: 0.75, rw: 0.032, rh: 0.024, phase: 1.8 },
    { bx: 0.55, by: 0.72, rw: 0.025, rh: 0.018, phase: 2.9 },
  ];
  rocks.forEach(r => {
    const rx = ((r.bx * w + tx * 0.45 + r.phase * 80) % (w * 1.25)) - w * 0.12;
    const ry = r.by * h - ty * 0.1;
    ctx2d.save();
    ctx2d.shadowColor = 'rgba(0,0,0,0.6)';
    ctx2d.shadowBlur = 10;
    ctx2d.shadowOffsetY = 5;
    ctx2d.fillStyle = '#1c0f07';
    ctx2d.beginPath();
    ctx2d.ellipse(rx, ry, r.rw * w, r.rh * h, 0.15, 0, Math.PI * 2);
    ctx2d.fill();
    ctx2d.fillStyle = 'rgba(60,28,10,0.35)';
    ctx2d.beginPath();
    ctx2d.ellipse(rx - r.rw*w*0.25, ry - r.rh*h*0.3, r.rw*w*0.5, r.rh*h*0.45, 0.15, 0, Math.PI);
    ctx2d.fill();
    ctx2d.restore();
  });

  if (S.nodeNearby) {
    const nx = w * 0.5, ny = h * 0.52;
    const t = Date.now() / 1000;
    ctx2d.save();
    ctx2d.strokeStyle = `rgba(0,200,255,${0.3 + Math.sin(t*3)*0.2})`;
    ctx2d.lineWidth = 1;
    ctx2d.setLineDash([3, 6]);
    ctx2d.beginPath();
    ctx2d.arc(nx, ny, 14 + Math.sin(t*2)*3, 0, Math.PI*2);
    ctx2d.stroke();
    ctx2d.setLineDash([]);
    ctx2d.fillStyle = `rgba(0,200,255,${0.5 + Math.sin(t*3)*0.3})`;
    ctx2d.beginPath();
    ctx2d.arc(nx, ny, 3, 0, Math.PI*2);
    ctx2d.fill();
    ctx2d.restore();
  }

  ctx2d.save();
  ctx2d.globalAlpha = 0.025;
  ctx2d.fillStyle = '#c88040';
  for (let i = 0; i < 40; i++) {
    const gx = (Math.sin(i * 13.7 + tx * 0.01) * 0.5 + 0.5) * w;
    const gy = (Math.cos(i * 7.3 + ty * 0.01) * 0.3 + 0.65) * h;
    ctx2d.fillRect(gx, gy, 1, 1);
  }
  ctx2d.globalAlpha = 1;
  ctx2d.restore();

  ctx2d.save();
  ctx2d.strokeStyle = 'rgba(0,200,255,0.018)';
  ctx2d.lineWidth = 0.5;
  for (let gx = 0; gx < w; gx += 44) { ctx2d.beginPath(); ctx2d.moveTo(gx,0); ctx2d.lineTo(gx,h); ctx2d.stroke(); }
  for (let gy = 0; gy < h; gy += 44) { ctx2d.beginPath(); ctx2d.moveTo(0,gy); ctx2d.lineTo(w,gy); ctx2d.stroke(); }
  ctx2d.restore();
}

let use3D = false;
let rAF2d = null;

function renderLoop2d() {
  drawTerrain2d();
  rAF2d = requestAnimationFrame(renderLoop2d);
}

const DIR_VECTORS = {
  N:[0,-1], NE:[1,-1], E:[1,0], SE:[1,1],
  S:[0,1], SW:[-1,1], W:[-1,0], NW:[-1,-1]
};

/* ============================================================
   THREE.JS 3D RENDERER — v2
   Additions over v1:
     • GLSL dust-storm fragment shader (full screen post-process)
     • Manual EffectComposer built on raw WebGLRenderTarget (no ESM)
     • Storm event bus hooks  →  onStormStart / onStormStop
     • Focal-length-based FOV mapping  (50mm idle, 100mm scan)
   Engine state machine: UNTOUCHED
   ============================================================ */
const Renderer3D = (() => {

  /* ── internal state ─────────────────────────────────────── */
  let renderer, scene, camera;
  let terrainMesh, geoNodeLight, sunLight, ambientLight, hemiLight;
  let rAF3d = null;
  let fogRef;
  let ready = false;
  let elapsedTime = 0;
  let lastTs = 0;

  // Terrain scroll
  let terrainTargetX = 0, terrainTargetZ = 0;
  let terrainCurrentX = 0, terrainCurrentZ = 0;

  // FOV (managed via focalLength → FOV conversion)
  const SENSOR_H     = 24.0;   // standard 35 mm full-frame height
  const BASE_FL      = 50.0;   // 50 mm = idle / moving
  const SCAN_FL      = 100.0;  // 100 mm = scanning (optical zoom-in feel)
  let   targetFL     = BASE_FL;
  let   currentFL    = BASE_FL;

  // Storm shader state
  let isStorming       = false;
  let stormIntensity   = 0.0;   // 0.0 → 1.0, animated in render loop

  /* ── post-process pipeline ──────────────────────────────── */
  // We replicate a minimal single-pass EffectComposer using raw
  // WebGLRenderTarget + a full-screen triangle, avoiding ESM imports.
  let renderTarget;        // scene renders here
  let postScene, postCam;  // fullscreen quad for shader pass
  let stormMesh;           // the quad carrying the storm ShaderMaterial
  let stormMaterial;

  /* ── GLSL shaders ───────────────────────────────────────── */
  const VERT_PASSTHROUGH = /* glsl */`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.0);
    }
  `;

  // Dust storm fragment shader — matches spec exactly,
  // extended with layered fbm noise for spatial variation
  const FRAG_STORM = /* glsl */`
    precision mediump float;

    uniform float     time;
    uniform float     intensity;   // 0.0 → 1.0
    uniform sampler2D tDiffuse;
    varying vec2      vUv;

    /* ── Classic 2D value noise (spec) ── */
    float noise(vec2 co) {
      return fract(sin(dot(co.yx, vec2(12.9898, 78.233))) * 43758.5453);
    }

    /* ── Smooth noise via bilinear lerp ── */
    float smoothNoise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);  // smoothstep
      float a = noise(i);
      float b = noise(i + vec2(1.0, 0.0));
      float c = noise(i + vec2(0.0, 1.0));
      float d = noise(i + vec2(1.0, 1.0));
      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }

    /* ── Fractional Brownian Motion (5 octaves) ── */
    float fbm(vec2 p) {
      float v = 0.0;
      float amp = 0.5;
      for (int i = 0; i < 5; i++) {
        v   += smoothNoise(p) * amp;
        p   *= 2.1;
        amp *= 0.48;
      }
      return v;
    }

    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);

      /* Mars dust — orange-brown, spec colour */
      vec3 dustColor = vec3(0.6, 0.3, 0.1);

      /* Animated fbm cloud pattern — gives spatial storm variation */
      vec2 uv2    = vUv * 3.5 + vec2(time * 0.04, time * 0.018);
      float cloud = fbm(uv2);

      /* High-frequency grain from spec noise (per-frame flicker) */
      float grain = noise(vUv * 180.0 + time * 12.7);

      /* Combine: spatial cloud shape controls where dust is dense */
      float dustMask = clamp(cloud * 1.4, 0.0, 1.0);

      /* Base dust overlay */
      vec3 col = mix(texel.rgb, dustColor, intensity * 0.62 * dustMask);

      /* Grain on top */
      col += grain * intensity * 0.16;

      /* Cheap blur emulation: desaturate + contrast reduction (spec) */
      float lum = dot(col, vec3(0.299, 0.587, 0.114));
      col = mix(col, vec3(lum), intensity * 0.52);

      /* Vignette tightens during storm — subtle edge darkening */
      float vign = 1.0 - smoothstep(0.35, 1.0,
                       length((vUv - 0.5) * vec2(1.0, 1.4)));
      col *= mix(1.0, vign, intensity * 0.45);

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  /* ── FOV ↔ focal-length conversion ─────────────────────── */
  // zoomFactor=1 → 50mm (≈39.6°), zoomFactor=2 → 100mm (≈20.4°)
  function focalLengthToFOV(fl) {
    return 2.0 * Math.atan(SENSOR_H / (2.0 * fl)) * (180.0 / Math.PI);
  }

  /* ── helpers ────────────────────────────────────────────── */
  function energyToAmbient(e) {
    if (e >= 30) return 0.35;
    if (e >= 15) return 0.12 + (e - 15) / 15 * 0.23;
    return 0.06 + (e / 15) * 0.06;
  }

  function energyToSun(e) {
    return 1.1 * Math.max(0.05, e / 100);
  }

  function pseudoNoise(x, z, seed) {
    const n = Math.sin(x * 12.9898 + z * 78.233 + seed) * 43758.5453;
    return n - Math.floor(n);
  }

  /* ── scene construction ─────────────────────────────────── */
  function buildScene() {
    scene = new THREE.Scene();

    fogRef = new THREE.Fog(0x03050a, 28, 90);
    scene.fog = fogRef;

    hemiLight = new THREE.HemisphereLight(0x180a06, 0x1c0e07, 0.4);
    scene.add(hemiLight);

    sunLight = new THREE.DirectionalLight(0xffd4a0, 1.1);
    sunLight.position.set(-8, 14, -6);
    scene.add(sunLight);

    ambientLight = new THREE.AmbientLight(0x1a0f07, 0.35);
    scene.add(ambientLight);

    geoNodeLight = new THREE.PointLight(0x00c8ff, 0.0, 12);
    geoNodeLight.position.set(0, 1.5, -8);
    scene.add(geoNodeLight);

    /* terrain */
    const tGeo = new THREE.PlaneGeometry(120, 120, 48, 48);
    tGeo.rotateX(-Math.PI / 2);
    const pos = tGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i), z = pos.getZ(i);
      const h = pseudoNoise(x * 0.08, z * 0.08, 42) * 1.4
               + pseudoNoise(x * 0.22, z * 0.22, 13) * 0.5
               + pseudoNoise(x * 0.55, z * 0.55, 99) * 0.18;
      pos.setY(i, h);
    }
    pos.needsUpdate = true;
    tGeo.computeVertexNormals();
    const tMat = new THREE.MeshStandardMaterial({ color: 0x2a1008, roughness: 0.95, metalness: 0.0 });
    terrainMesh = new THREE.Mesh(tGeo, tMat);
    terrainMesh.position.set(0, -1.8, 0);
    scene.add(terrainMesh);

    /* rocks */
    const rockGeos = [
      new THREE.BoxGeometry(1.2, 0.7, 0.9),
      new THREE.BoxGeometry(0.7, 0.5, 0.8),
      new THREE.BoxGeometry(2.1, 1.0, 1.6),
      new THREE.BoxGeometry(0.5, 0.4, 0.5),
      new THREE.BoxGeometry(1.5, 0.8, 1.2),
    ];
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x1c0f07, roughness: 0.98, metalness: 0.0 });
    const rockPositions = [
      [-4.5,-1.4,-7.0],[3.2,-1.5,-8.5],[-8.0,-1.3,-6.0],
      [6.5,-1.5,-7.5],[-2.0,-1.4,-10.0],[8.0,-1.3,-5.5],
      [-6.0,-1.5,-9.0],[1.5,-1.4,-6.5],[-9.5,-1.4,-8.0],
      [4.8,-1.4,-11.0],[-1.2,-1.5,-13.0],[7.2,-1.3,-10.5],
      [-5.5,-1.5,-4.5],[2.8,-1.4,-4.0],[-3.8,-1.5,-15.0],
      [9.5,-1.4,-8.0],
    ];
    rockPositions.forEach((p, i) => {
      const geo  = rockGeos[i % rockGeos.length].clone();
      const mesh = new THREE.Mesh(geo, rockMat);
      mesh.position.set(p[0], p[1], p[2]);
      mesh.rotation.y = pseudoNoise(p[0], p[2], 7) * Math.PI * 2;
      mesh.rotation.x = (pseudoNoise(p[0], p[2], 3) - 0.5) * 0.3;
      mesh.scale.setScalar(0.6 + pseudoNoise(p[0], p[2], 5) * 0.8);
      scene.add(mesh);
    });

    /* sky dome */
    const skyGeo = new THREE.SphereGeometry(80, 16, 8);
    skyGeo.scale(-1, 1, 1);
    scene.add(new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({ color: 0x060204 })));

    /* horizon glow */
    const hzMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 12),
      new THREE.MeshBasicMaterial({ color: 0x3a0e04, transparent: true, opacity: 0.18, depthWrite: false })
    );
    hzMesh.position.set(0, 2, -35);
    scene.add(hzMesh);
  }

  /* ── post-process: manual single-pass composer ──────────── */
  // Renders scene → WebGLRenderTarget, then draws target texture
  // through the storm ShaderMaterial on a fullscreen NDC triangle.
  function buildPostProcess(w, h) {
    renderTarget = new THREE.WebGLRenderTarget(w, h, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
    });

    stormMaterial = new THREE.ShaderMaterial({
      uniforms: {
        tDiffuse:  { value: renderTarget.texture },
        time:      { value: 0.0 },
        intensity: { value: 0.0 },
      },
      vertexShader:   VERT_PASSTHROUGH,
      fragmentShader: FRAG_STORM,
      depthWrite: false,
      depthTest:  false,
    });

    // Fullscreen NDC triangle (more efficient than quad)
    const triGeo = new THREE.BufferGeometry();
    triGeo.setAttribute('position', new THREE.BufferAttribute(
      new Float32Array([-1,-1,0,  3,-1,0,  -1,3,0]), 3
    ));
    triGeo.setAttribute('uv', new THREE.BufferAttribute(
      new Float32Array([0,0,  2,0,  0,2]), 2
    ));

    stormMesh = new THREE.Mesh(triGeo, stormMaterial);
    stormMesh.frustumCulled = false;

    postScene = new THREE.Scene();
    postScene.add(stormMesh);

    // Orthographic camera — covers NDC exactly, no projection needed
    postCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
  }

  /* ── init ───────────────────────────────────────────────── */
  function init() {
    if (!window.THREE) return false;
    const canvas = document.getElementById('threejs-canvas');
    const vp     = document.getElementById('viewport');
    const W = vp.offsetWidth, H = vp.offsetHeight;

    try {
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        powerPreference: 'low-power',
        alpha: false,
      });
    } catch(e) {
      console.warn('HEX01: WebGL init failed, falling back to 2D canvas');
      return false;
    }

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(W, H);
    renderer.setClearColor(0x03050a, 1);

    camera = new THREE.PerspectiveCamera(focalLengthToFOV(BASE_FL), W / H, 0.1, 200);
    camera.position.set(0, 3.5, 6);
    camera.lookAt(0, -0.5, -4);

    buildScene();
    buildPostProcess(W, H);

    window.addEventListener('resize', () => {
      const w = vp.offsetWidth, h = vp.offsetHeight;
      renderer.setSize(w, h);
      renderTarget.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    ready = true;
    return true;
  }

  /* ── render loop ────────────────────────────────────────── */
  const MOBILE   = window.matchMedia('(pointer: coarse)').matches;
  const FRAME_MS = MOBILE ? 1000 / 30 : 1000 / 60;

  function renderLoop(ts) {
    rAF3d = requestAnimationFrame(renderLoop);
    if (ts - lastTs < FRAME_MS) return;
    const dt = Math.min((ts - lastTs) / 1000, 0.05); // cap at 50 ms
    lastTs      = ts;
    elapsedTime += dt;

    /* ── storm intensity lerp — 2 s to full, 2 s to clear ── */
    const stormRate = dt * 0.5; // 0→1 in 2 seconds
    if (isStorming) {
      stormIntensity = Math.min(1.0, stormIntensity + stormRate);
    } else {
      stormIntensity = Math.max(0.0, stormIntensity - stormRate);
    }

    /* ── FOV via focal-length lerp ── */
    if (Math.abs(currentFL - targetFL) > 0.05) {
      currentFL += (targetFL - currentFL) * 0.04;
      camera.fov = focalLengthToFOV(currentFL);
      camera.updateProjectionMatrix();
    }

    /* ── terrain translation lerp ── */
    terrainCurrentX += (terrainTargetX - terrainCurrentX) * 0.025;
    terrainCurrentZ += (terrainTargetZ - terrainCurrentZ) * 0.025;
    if (terrainMesh) {
      terrainMesh.position.x = terrainCurrentX;
      terrainMesh.position.z = terrainCurrentZ;
    }

    /* ── update storm shader uniforms ── */
    stormMaterial.uniforms.time.value      = elapsedTime;
    stormMaterial.uniforms.intensity.value = stormIntensity;

    /* ── two-pass render ── */
    // Pass 1: scene → renderTarget
    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, camera);

    // Pass 2: renderTarget texture → screen through storm shader
    renderer.setRenderTarget(null);
    renderer.render(postScene, postCam);
  }

  /* ── lifecycle ──────────────────────────────────────────── */
  function start() {
    if (!ready) return;
    document.getElementById('threejs-canvas').style.display = 'block';
    lastTs = performance.now();
    rAF3d  = requestAnimationFrame(renderLoop);
  }

  function stop() {
    if (rAF3d) { cancelAnimationFrame(rAF3d); rAF3d = null; }
  }

  /* ── storm event hooks (called by engine triggerStorm) ──── */
  function onStormStart() { isStorming = true; }
  function onStormStop()  { isStorming = false; }

  /* ── snapshot handler ───────────────────────────────────── */
  function applySnapshot(snap) {
    if (!ready) return;

    /* lighting from energy */
    sunLight.intensity     = energyToSun(snap.energy);
    ambientLight.intensity = energyToAmbient(snap.energy);

    /* fog: storm tightens near/far regardless of shader —
       the shader handles the visual dust;
       fog handles geometry occlusion at distance */
    if (snap.stormActive) {
      fogRef.near = 6;
      fogRef.far  = 28;
      sunLight.intensity *= 0.28;
    } else {
      fogRef.near = 28;
      fogRef.far  = 90;
    }

    /* geo-node pulse light */
    geoNodeLight.intensity = snap.nodeNearby ? 0.55 : 0.0;

    /* focal-length target:
       SCANNING  → 100 mm  (≈ 20.4° — tight instrument view)
       otherwise → 50 mm   (≈ 39.6° — standard nav view)    */
    targetFL = (snap.roverState === 'SCANNING') ? SCAN_FL : BASE_FL;

    /* direction indicator HUD element */
    const dirEl = document.getElementById('dir-indicator');
    if (snap.lastDir) {
      dirEl.textContent = 'HDG: ' + snap.lastDir;
      dirEl.classList.add('visible');
    }

    /* terrain world offset on move */
    if (snap.roverState === 'MOVING' && snap.lastDir) {
      const v = DIR_VECTORS[snap.lastDir] || [0,0];
      terrainTargetX += v[0] * 4;
      terrainTargetZ += v[1] * 4;
    }
  }

  return {
    init,
    start,
    stop,
    applySnapshot,
    onStormStart,
    onStormStop,
    isReady: () => ready,
  };
})();

/* ============================================================
   EVENT BUS (minimal inline)
   ============================================================ */
const HEX01_Bus = (() => {
  const target = new EventTarget();
  return {
    dispatch(type, detail) {
      target.dispatchEvent(new CustomEvent(type, { detail }));
    },
    on(type, fn) {
      target.addEventListener(type, e => fn(e.detail));
    }
  };
})();

function HEX01_Snapshot() {
  return {
    energy:       S.energy,
    roverState:   S.roverState,
    stormActive:  S.stormActive,
    nodeNearby:   S.nodeNearby,
    currentTerrain: {
      name:            S.currentTerrain.name,
      complexityIndex: S.currentTerrain.complexityIndex,
      hazards:         { ...S.currentTerrain.hazards }
    },
    lastDir:      S._lastDir,
    simScreen:    document.getElementById('sim-screen').classList.contains('active')
  };
}

HEX01_Bus.on('stateChange', snap => {
  if (Renderer3D.isReady()) Renderer3D.applySnapshot(snap);
});

/* ============================================================
   KEYBOARD CONTROLLER
   ============================================================ */
const KEY_DIR = {
  ArrowUp:'N', ArrowDown:'S', ArrowLeft:'W', ArrowRight:'E',
  w:'N', s:'S', a:'W', d:'E',
  q:'NW', e:'NE', z:'SW', c:'SE'
};
document.addEventListener('keydown', ev => {
  const dir = KEY_DIR[ev.key];
  if (dir && !ev.repeat && document.getElementById('sim-screen').classList.contains('active')) {
    move(dir);
  }
});

/* ============================================================
   CORE FUNCTIONS — ORIGINAL ENGINE PRESERVED VERBATIM
   ============================================================ */

function initiateControl() {
  document.getElementById('boot-screen').classList.remove('active');
  const ss = document.getElementById('sim-screen');
  ss.classList.add('active');

  // Attempt 3D init; fall back to 2D
  const ok3d = Renderer3D.init();
  if (ok3d) {
    use3D = true;
    document.getElementById('terrain-canvas').style.display = 'none';
    document.getElementById('threejs-canvas').style.display = 'block';
    Renderer3D.start();
  } else {
    use3D = false;
    document.getElementById('terrain-canvas').style.display = 'block';
    document.getElementById('threejs-canvas').style.display = 'none';
    initCanvas2d();
    renderLoop2d();
  }

  updateUI();
  startLoops();
}

function endSim() {
  document.getElementById('fail-modal').classList.remove('open');
  document.getElementById('sim-screen').classList.remove('active');
  document.getElementById('boot-screen').classList.add('active');

  clearInterval(loops.ambient);
  clearInterval(loops.solar);
  clearInterval(loops.nodes);

  if (use3D) {
    Renderer3D.stop();
  } else {
    if (rAF2d) { cancelAnimationFrame(rAF2d); rAF2d = null; }
  }

  S.energy = 84;
  S.validation = 0;
  S.roverState = 'IDLE';
  S.stormActive = false;
  S.playableLatencyMs = 1200;
  S.simLatencySeconds = MISSION_CONFIG.communications.latency.averageMs / 1000;
  S.nodeNearby = false;
  S._lastDir = null;
  S.currentTerrain = TERRAIN_DATABASE[0];
  challengeIdx = 0;
  selectedChoiceIdx = null;
  tx = 0; ty = 0;
}

function updateUI() {
  const pct = Math.max(0, Math.floor(S.energy));
  document.getElementById('eb-fill').style.width = pct + '%';
  document.getElementById('energy-text').textContent = pct + '%';
  const fill = document.getElementById('eb-fill');
  fill.style.background = pct < 15 ? 'var(--red)' : pct < 30 ? 'var(--amber)' : 'var(--accent)';

  const mins = Math.floor(S.simLatencySeconds / 60);
  const secs = Math.floor(S.simLatencySeconds % 60);
  document.getElementById('latency-text').innerHTML =
    `<span class="sig-dot"></span>${mins}m ${secs}s`;

  document.getElementById('val-text').textContent = S.validation + ' pts';
  document.getElementById('val-chip-val').textContent = S.validation;

  document.getElementById('to-name').textContent = S.currentTerrain.name.toUpperCase();
  document.getElementById('to-cmplx').textContent = S.currentTerrain.complexityIndex;
  document.getElementById('to-slip').textContent = (S.currentTerrain.hazards.slipProbability * 100).toFixed(0) + '%';

  const stateEl = document.getElementById('sr-state');
  stateEl.textContent = S.roverState;
  stateEl.className = 'sys-val ' +
    (S.roverState === 'IDLE' ? 'ok' : S.roverState === 'SCANNING' ? 'warn' : '');

  document.getElementById('sr-temp').textContent  = S.stormActive ? '-85.4°C' : '-54.2°C';
  const solarEl = document.getElementById('sr-solar');
  solarEl.textContent = S.stormActive ? 'COMPROMISED' : 'OPTIMAL';
  solarEl.className   = 'sys-val ' + (S.stormActive ? 'warn' : 'ok');

  const rsb = document.getElementById('rsb');
  rsb.textContent = S.roverState;
  rsb.className = 'rover-state-badge ' +
    (S.roverState.includes('MOVING') ? 'moving' : S.roverState === 'SCANNING' ? 'scanning' : '');

  const scanBtn = document.getElementById('scan-btn');
  const canScan = S.nodeNearby && S.roverState === 'IDLE';
  scanBtn.className = 'scan-btn' + (canScan ? ' ready' : '');
  const scnBtn = document.getElementById('d-scan');
  if (scnBtn) {
    scnBtn.style.borderColor = canScan ? 'var(--accent)' : '';
    scnBtn.style.color = canScan ? 'var(--accent)' : '';
    scnBtn.style.boxShadow = canScan ? '0 0 8px rgba(0,200,255,0.3)' : '';
  }

  document.getElementById('node-pill').classList.toggle('visible', S.nodeNearby);
  document.getElementById('storm-badge').classList.toggle('visible', S.stormActive);
  document.getElementById('storm-veil').classList.toggle('active', S.stormActive);
  document.getElementById('hb-veil').classList.toggle('pulse', S.energy < 15);

  if (S.energy <= 0) {
    document.getElementById('fail-modal').classList.add('open');
  }

  // Dispatch snapshot to renderer — append-only addition
  HEX01_Bus.dispatch('stateChange', HEX01_Snapshot());
}

function logToast(msg) {
  document.getElementById('toast-log').textContent = 'SYS: ' + msg;
}

/* ── LOOPS ──────────────────────────────────────────────── */
function startLoops() {
  loops.solar = setInterval(() => {
    if (S.roverState === 'IDLE' && S.energy < 100) {
      const chargeBase = 0.5;
      const charge = S.stormActive
        ? chargeBase * MISSION_CONFIG.powerSystems.solar.dustStormMultiplier
        : chargeBase;
      S.energy = Math.min(100, S.energy + charge);
      if (!S.stormActive) {
        const sg = document.getElementById('solar-glow');
        sg.classList.add('active');
        setTimeout(() => sg.classList.remove('active'), 2500);
      }
      updateUI();
    }
  }, 2000);

  loops.nodes = setInterval(() => {
    if (S.roverState === 'MOVING' && Math.random() < 0.2 && !S.nodeNearby) {
      S.nodeNearby = true;
      logToast('GEO-NODE PROXIMITY ALERT — INITIATE SCAN');
      updateUI();
    }
  }, 4000);
}

/* ── MOVE ───────────────────────────────────────────────── */
function move(dir) {
  if (S.roverState !== 'IDLE' || S.energy <= 0) return;

  S._lastDir = dir;
  S.roverState = 'MOVING_QUEUED';
  logToast(`CMD [MOVE ${dir}] TRANSMITTING…`);

  const btn = document.getElementById('d-' + dir);
  if (btn) btn.classList.add('lit');

  document.getElementById('lat-banner').classList.add('visible');
  updateUI();

  setTimeout(() => {
    if (btn) btn.classList.remove('lit');
    document.getElementById('lat-banner').classList.remove('visible');
    executeMove(dir);
  }, S.playableLatencyMs);
}

function executeMove(dir) {
  S.roverState = 'MOVING';
  S.currentTerrain = TERRAIN_DATABASE[Math.floor(Math.random() * TERRAIN_DATABASE.length)];

  const drain = MISSION_CONFIG.locomotion.baseEnergyDrainPerMove * S.currentTerrain.hazards.costMult;
  S.energy -= drain;

  const v = DIR_VECTORS[dir] || [0,0];
  tx += v[0] * 18;
  ty += v[1] * 18;

  if (Math.random() < S.currentTerrain.hazards.slipProbability) {
    logToast('HAZARD: WHEEL SLIP — EXTRA POWER DRAWN');
    S.energy -= 2.5;
  } else {
    logToast(`MOVED ${dir} · TERRAIN: ${S.currentTerrain.name.toUpperCase()}`);
  }

  if (Math.random() < 0.05) triggerStorm();

  setTimeout(() => {
    S.roverState = 'IDLE';
    updateUI();
  }, 1000);

  updateUI();
}

/* ── STORM ──────────────────────────────────────────────── */
function triggerStorm() {
  S.stormActive = true;
  S.simLatencySeconds += 300;

  // Emit to bus + direct renderer hook — ramps shader intensity up
  HEX01_Bus.dispatch('onStormStart', {});
  if (Renderer3D.isReady()) Renderer3D.onStormStart();

  logToast('WARNING: DUST STORM DETECTED — SOLAR COMPROMISED');
  updateUI();

  setTimeout(() => {
    S.stormActive = false;
    S.simLatencySeconds -= 300;

    // Emit to bus + direct renderer hook — ramps shader intensity down
    HEX01_Bus.dispatch('onStormStop', {});
    if (Renderer3D.isReady()) Renderer3D.onStormStop();

    logToast('STORM CLEARED — NOMINAL OPERATIONS RESUMED');
    updateUI();
  }, 15000);
}

/* ── SCAN ───────────────────────────────────────────────── */
function startScan() {
  if (!S.nodeNearby || S.roverState !== 'IDLE') return;
  if (S.energy < MISSION_CONFIG.instruments.apxs_spectrometer.energyCostPct) {
    logToast('ERROR: INSUFFICIENT ENERGY FOR APXS SCAN');
    return;
  }

  S.roverState = 'SCANNING';
  logToast('APXS SCAN INITIATED — PROCESSING…');
  document.getElementById('cam-data').textContent = 'SCANNING…\nANALYSING…\nPROCESSING…';
  document.getElementById('scan-sweep').classList.add('active');
  updateUI();

  setTimeout(() => {
    S.energy -= MISSION_CONFIG.instruments.apxs_spectrometer.energyCostPct;
    document.getElementById('scan-sweep').classList.remove('active');
    document.getElementById('cam-data').innerHTML = 'FOCAL 50mm<br>ISO 800<br>EXP 1/250';
    S.roverState = 'IDLE';
    S.nodeNearby = false;
    updateUI();
    showChallenge();
  }, S.playableLatencyMs);
}

/* ── CHALLENGE MODAL ────────────────────────────────────── */
function showChallenge() {
  const ch = CHALLENGES[challengeIdx % CHALLENGES.length];
  selectedChoiceIdx = null;

  document.getElementById('c-qid').textContent = '◈ ' + ch.id + ' · ' + ch.instrument;
  const diffEl = document.getElementById('c-diff');
  diffEl.textContent = ch.difficulty;
  diffEl.className = 'difficulty-badge diff-' + ch.difficulty.toLowerCase().replace(/[ ]+/g,'-');

  document.getElementById('c-title').textContent = ch.title;
  document.getElementById('c-sub').textContent   = ch.sub;
  document.getElementById('q-text').textContent  = ch.question;

  document.getElementById('explanation-box').style.display = 'none';
  document.getElementById('exp-text').textContent = '';

  const div = document.getElementById('choices-div');
  div.innerHTML = '';
  ch.choices.forEach((c, i) => {
    const btn = document.createElement('button');
    btn.className = 'c-btn';
    btn.textContent = c.text;
    btn.onclick = () => selectChoice(i);
    div.appendChild(btn);
  });

  const sb = document.getElementById('submit-btn');
  sb.style.display = 'none';
  sb.textContent = 'TRANSMIT ANALYSIS';
  sb.onclick = submitAnswer;
  document.getElementById('challenge-modal').classList.add('open');
}

function selectChoice(idx) {
  selectedChoiceIdx = idx;
  document.querySelectorAll('.c-btn').forEach((b, i) => {
    b.classList.toggle('selected', i === idx);
  });
  document.getElementById('submit-btn').style.display = 'block';
}

function submitAnswer() {
  if (selectedChoiceIdx === null) return;
  const ch = CHALLENGES[challengeIdx % CHALLENGES.length];
  const correct = ch.choices[selectedChoiceIdx].correct;

  document.querySelectorAll('.c-btn').forEach((b, i) => {
    b.onclick = null;
    if (ch.choices[i].correct) b.classList.add('correct');
    else if (i === selectedChoiceIdx && !correct) b.classList.add('wrong');
  });

  if (ch.explanation) {
    document.getElementById('exp-text').textContent = ch.explanation;
    document.getElementById('explanation-box').style.display = 'block';
  }

  const sb = document.getElementById('submit-btn');
  sb.textContent = correct ? 'CONFIRMED · CONTINUE MISSION' : 'ACKNOWLEDGED · CONTINUE';
  sb.style.display = 'block';
  sb.onclick = () => {
    sb.onclick = submitAnswer;
    document.getElementById('challenge-modal').classList.remove('open');
    applyResult(correct);
  };
}

/* ── RESULT ─────────────────────────────────────────────── */
function applyResult(correct) {
  let energyDelta, valDelta, latDelta;

  if (correct) {
    S.validation += 10;
    energyDelta = +8;
    valDelta    = '+10 pts';
    latDelta    = '—';
    logToast('VALIDATION SUCCESS · DATA PACKET LOGGED');
    challengeIdx++;
  } else {
    S.energy -= 5;
    S.simLatencySeconds += 120;
    S.playableLatencyMs += 300;
    energyDelta = -5;
    valDelta    = '0 pts';
    latDelta    = '+120s';
    logToast('ERROR: DATA INCONCLUSIVE · PENALTY APPLIED');
  }

  S.energy = Math.min(100, S.energy + (correct ? 8 : 0));

  const _ch = CHALLENGES[(correct ? challengeIdx - 1 : challengeIdx) % CHALLENGES.length];
  document.getElementById('r-tag').textContent   = correct ? '◈ LOGGED · ' + _ch.id : '✕ REJECTED · ' + _ch.id;
  document.getElementById('r-title').textContent = correct ? 'Sample Integrity Confirmed' : 'Analysis Inconclusive';
  document.getElementById('r-sub').textContent   = _ch.instrument + ' · ' + (correct
    ? 'Data validated. Survey region unlocked.'
    : 'Incorrect interpretation. Energy & latency penalty applied.');

  const rE = document.getElementById('r-energy');
  rE.textContent = (energyDelta >= 0 ? '+' : '') + energyDelta + '%';
  rE.className   = 'r-stat-val' + (energyDelta < 0 ? ' neg' : '');

  const rV = document.getElementById('r-val');
  rV.textContent = valDelta;
  rV.className   = 'r-stat-val' + (valDelta === '0 pts' ? ' amber' : '');

  const rL = document.getElementById('r-lat');
  rL.textContent = latDelta;
  rL.className   = 'r-stat-val' + (latDelta !== '—' ? ' neg' : '');

  document.getElementById('result-modal').classList.add('open');
  updateUI();
}

function closeResult() {
  document.getElementById('result-modal').classList.remove('open');
}

/* ── BOOT SEQUENCE ──────────────────────────────────────── */
const BOOT_LINES = [
  { text: 'DSN Relay Node 7 …',        key: null,           val: 'CONNECTING',  cls: '' },
  { text: 'Signal established.',        key: null,           val: 'OK',          cls: 'bl-ok' },
  { text: 'Rover ID:',                  key: 'HEX-01',       val: null,          cls: '' },
  { text: 'Mission:',                   key: 'Geological Survey · Quadrant A3', val: null, cls: '' },
  { text: 'Solar charge:',             key: '84%',          val: null,          cls: '' },
  { text: 'Signal latency:',           key: '12m 30s',      val: null,          cls: '' },
  { text: 'APXS spectrometer:',        key: 'NOMINAL',      val: null,          cls: '' },
  { text: '3D renderer:',              key: window.THREE ? 'THREE.JS r128 + GLSL STORM SHADER' : 'FALLBACK 2D', val: null, cls: '' },
  { text: 'All systems nominal.',       key: null,           val: 'READY',       cls: 'bl-ok' },
];

(function runBoot() {
  const log  = document.getElementById('boot-log');
  const fill = document.getElementById('boot-progress-fill');
  const cta  = document.getElementById('boot-cta');

  BOOT_LINES.forEach((line, i) => {
    setTimeout(() => {
      const el = document.createElement('div');
      el.className = 'boot-line';
      let html = `<span>${line.text}</span>`;
      if (line.key) html += ` <span class="bl-key">${line.key}</span>`;
      if (line.val) html += ` <span class="${line.cls || 'bl-val'}">${line.val}</span>`;
      el.innerHTML = html;
      log.appendChild(el);
      fill.style.width = ((i + 1) / BOOT_LINES.length * 100) + '%';
    }, 320 * (i + 1));
  });

  setTimeout(() => {
    cta.classList.add('visible');
  }, 320 * (BOOT_LINES.length + 1) + 200);
})();

</script>
</body>
</html>
